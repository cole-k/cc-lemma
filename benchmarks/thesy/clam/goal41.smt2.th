(datatype Nat () ((succ Nat Nat) (zero Nat)))
(datatype Lst () ((cons Nat Lst Lst) (nil Lst)))
(declare-fun mem (Nat Lst) Bool)
(declare-fun lst-mem (Nat Lst) Bool)
(declare-fun lst-subset (Lst Lst) Bool)
(declare-fun lst-eq (Lst Lst) Bool)
(declare-fun lst-intersection (Lst Lst) Lst)
(declare-fun leq (Nat Nat) Bool)
(=> rule0 (leq ?__x0 ?__y1) (or (= ?__x0 ?__y1) (less ?__x0 ?__y1)))
(=> rule1 (or (= ?__x0 ?__y1) (less ?__x0 ?__y1)) (leq ?__x0 ?__y1))
(=> rule2 (lst-mem ?n ?x) (mem ?n ?x))
(=> rule3 (mem ?n ?x) (lst-mem ?n ?x))
(=> rule4 (lst-subset nil ?x) true)
(=> rule5 (lst-subset (cons ?n ?x) ?y) (and (lst-subset ?x ?y) (lst-mem ?n ?y)))
(=> rule6 (and (lst-subset ?x ?y) (lst-mem ?n ?y)) (lst-subset (cons ?n ?x) ?y))
(=> rule7 (lst-eq ?x ?y) (and (lst-subset ?x ?y) (lst-subset ?y ?x)))
(=> rule8 (and (lst-subset ?x ?y) (lst-subset ?y ?x)) (lst-eq ?x ?y))
(=> rule9 (lst-intersection nil ?x) nil)
(=> rule10 (lst-intersection (cons ?n ?x) ?y) (ite (lst-mem ?n ?y) (cons ?n (lst-intersection ?x ?y)) (lst-intersection ?x ?y)))
(=> rule11 (ite (lst-mem ?n ?y) (cons ?n (lst-intersection ?x ?y)) (lst-intersection ?x ?y)) (lst-intersection (cons ?n ?x) ?y))
(prove (forall ((y Lst)(x Lst)) (=> (lst-subset x y) (lst-eq (lst-intersection x y) x))))
